---
title: 面向对象

categories: 
- python
tags:
- python
---
## 语言的分类

面向机器:抽象成机器指令, 机器容易理解.
代表:汇编语言
面向过程:
做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.
问题规模小, 可以步骤化.按部就班处理.
代表:c语言
面向对象OOP
随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.
代表:C++, java, python等
## 面向对象
类:class
类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.
用计算机语言来描述类,是属性和方法的集合.
对象:instance, object
对象是类的具象, 是一个实体.
对于我们每个人这个个体, 都是抽象概念人类不同的实体.

属性:它是对象状态的抽象,用数据结构来描述.
操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.
哲学:
一切皆对象
对象是数据和操作的封装.
对象是独立的,但是对象之间可以相互作用.
目前OOP是最接近人类认知的编程范式.

## 三要素
1.封装
组装:将数据和操作组装到一起.
隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的
构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.
2.继承
多复用,继承来的就不用了自己写了
多继承少修改,OCP,使用继承来改变,来体现个性.
3.多态
面向对象编程最灵活的地方,动态绑定
人类就是封装
人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:
多态,继承自动物类的人类,猫类的操作'吃'不同.

python的类:
1.必须使用class关键字
2.类名必须使用大驼峰命名
3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.

## 类对象及类属性

类对象,类的定义执行后会生成一个类对象.
类的属性,类定义中的变量和类中定义的方法都是类的属性.
类变量,
self指代当前实例本身.

## 实例化
a = Myclass() # 实例化
使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.
实例化就真正创建一个该类的对象
tom = Person()
jerry = Person()
每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.
python类实例化后, 会调用__init__方法,这个方法第一个形式参数必须留给self,其他参数随意.
__init__方法

注意:__init__()方法不能有返回值,也就是只能是return None

实例对象instance
类实例化后一定会获得一个类的实例,就是实例对象
__init__方法的第一参数self就是指代某一个实例自身.
类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.

实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.

总结:
是类的,也就是这个类所有实例的,器实例都可以访问到:
是实例的,就是这个实例自己的,通过类访问不到.
类变量是属于类的变量,这个类的所有实例可以共享这个变量.
对象可以动态的给自己增加一个属性.
实例属性的查找顺序
指的是实例使用,.点号来访问属性.会先找自己的__dict__,如果没有,然后通过属性__class__找到自家的类, 再去类的__dict__中找.
注意:如果实例使用__dict__访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.

一般来说, 类变量可使用全大写来命名.

## 类方法和静态方法

类方法:
1.在类定义中,使用@classmethod装饰器的方法
2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.
3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改
4.通过cls可以直接操作类的属性.
静态方法:
在类定义中, 使用@staticmethod装饰器的方法
2在调用时, 不会隐式的传入参数.
静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.

类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,
原因是第一参数必须是类的实例.
总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.
实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.
实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.

访问控制:
私有属性
私有属性,使用双下划线开头的属性名就是私有属性.

私有属性的本质:
类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.


保护变量:
在变量名前使用一个下划线,称为保护变量
这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.
私有方法:
参照保护变量,私有变量,使用单下划线,双下化线的命名方法,

## 补丁
可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变
猴子补丁:
在运行时,对属性,方法,函数,等进行动态替换
其目的往往是为了通过替换,修改来增强,扩展原有代码的能力

## 属性装饰器
一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.

property装饰器

后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性
setter装饰器
可以控制是否删除属性,很少用
deleter装饰器
可以控制是否删除属性,很少用
property装饰器必须在前,setter deleter装饰器在后,
property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.

## 对象的销毁
类中可以定义__del__方法 ,称为析构函数.
作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.
注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.
使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用__del__方法.
由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.
封装:
将数据和操作组织到类中,即属性和方法.
将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.
通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.
