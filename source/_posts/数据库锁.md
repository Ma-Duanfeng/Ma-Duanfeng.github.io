数据库锁设计的初衷是处理并发问题, 作为多用户共享的资源, 当出现并发访问的时候, 数据库需要合理地控制资源的访问规则.而锁就是用来实现这些访问规则的重要数据结构.

根据加锁的范围, mysql里面的锁大致可以分为全局锁, 表级锁, 行锁三类, 这里需要说明的是, 锁的设计比较复杂.

### 全局锁

顾明思议, 全局锁就是对整个数据库实例加锁, mysql提供了一个加全局读锁的方法, 命令时Flush tables with read lock.当你需要让整个库处于只读状态的时候, 可以使用这个命令, 之后其他线程的以下语句会被阻塞: 数据更新语句(数据的增删改), 数据定义语句( 包括建表, 修改表结构) 和更新事务的提交语句.

全局锁的典型使用场景是, 做全库逻辑备份.也就是把整个每个表都select出来存成文本.

以前有一种做法, 是通过ftwrl 确保不会有其他线程对数据库做更新, 然后对整个库做备份.注意, 在备份过程中整个库完全处于只读状态.

但是让整库都只读, 听上去就很危险:

- 如果你在主库上备份, 那么在备份期间都不能执行更新, 业务基本上就得停摆;
- 如果你在从库上备份, 那么备份期间从库不能执行主库同步过来的binlog.会导致主从延迟.

看来加全局锁不太好, 但是细想一下, 备份为什么要加锁? 我们来看一下不加锁会有什么问题

假设你现在要维护购买系统, 关注的是用户账户余额表和用户课程表.

现在发起一个逻辑备份.假设备份期间, 有一个用户, 他购买了一门课程